# MyHTTP

## Цель задания

Реализовать примитивную HTTP коммуникацию поверх TCP, используя интерфейсы из стандартного пакета `net/http`. Реализация
должна уметь относительно бесшовно заменять стандартные `http.Server/Client` из `net/http`

## Общая информация

Вам предстоит сделать все компоненты для своего мини-HTTP фреймворка: сервер, клиент и сериализаторы, а так же
реализовать свой хэндлер.

Сделать все это на уровне стандартной библиотеки, обработать все крайние случаи и возможности заложенные в протокол,
конечно, невозможно в рамках одной домашки, поэтому вводим следующие ограничения:

1) Работаем с `HTTP/1.1`, так как он самый актуальный из не бинарно кодируемых версий
2) Исключаем `keepalive`, формы через `x-www-form-urlencoded`, отправку файлов, и прочие специфические форматы, работаем
   с обычным тестом/json
3) Фиксируем длину данных либо через `Content-Length`, либо через `Transfer-Encoding: chunked`,
   подробнее [тут](https://ru.wikipedia.org/wiki/Chunked_transfer_encoding)
4) **ВСЕ** проверяемые корнеркейсы уже описаны и автоматизированы в тестах, если у вас проходят тесты - ваша логика
   подходит. Вы все еще можете усложнить ее, добавить дополнительные проверки и т.д., если будуете это делать -
   отпишитесь об этом в файл в папке с заданием
5) Во всех реализациях вам запрещено пользоваться **прямыми аналогами** из `net/http`, то есть например нельзя
   сериализовать `http.Request`через `request.Write()`, или реализовать `server.ListenAndServe` через
   `http.ListenAndServe`. При этом пользоваться другими полезными типами из `net/http` и связанных пакетов можно и
   нужно, например вам наверняка пригодятся `http.Header` или `url.Url`
6) Вы можете опираться в логике реализации или смотреть как решаются те или иные проблемы в прямых аналогах, но прямое
   копирование запрещено.

## Задачи

### 1. (Де)Сериализация HTTP запросов и ответов ([convert/http.go](convert/http.go))

#### Нужно реализовать следующие функции

- `ParseRequest` - парсинг HTTP запроса из `Reader` в `*http.Request`
- `WriteRequest` - запись `*http.Request` в `Writer`
- `ParseResponse` - парсинг HTTP ответа из `Reader` в `*http.Response`
- `WriteResponse` - запись `*http.Response` в `Writer`

**Еще раз, важно:** вам запрещено пользоваться `request.Write`, `response.Write` и прочими встроенными функциями для
(де)сериализации.

#### Полезное

1) Структура HTTP request и reponse https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Messages
2) [Transfer-Endcoing](https://ru.wikipedia.org/wiki/Chunked_transfer_encoding)
3) [net/http](https://pkg.go.dev/net/http#pkg-types)
2) Формальное определение того как устроены сообщения в HTTP/1.1: [RFC7230](https://tools.ietf.org/html/rfc7230)

### 2. HTTP клиент ([client/client.go](client/client.go))

#### Нужно

- Реализовать интерфейс `HTTPClient` с методом `Do(*http.Request) (*http.Response, error)`
- Использовать TCP соединения для отправки запросов
- Использовать написанные ранее функции из пакета `convert/` для парсинга/записи запросов и ответов

**Еще раз, важно:** вам запрещено пользоваться `http.Get`, `http.Client` и прочими аналогами для отправки запросов.

#### Полезное

1) Пакет [net](https://pkg.go.dev/net#pkg-overview) с основными сетевыми примитивами
2) Для вдохновения [http.Client](https://cs.opensource.google/go/go/+/refs/tags/go1.25.3:src/net/http/client.go;l=57)

### 3. ResponseWriter ([server/response_writer.go](server/response_writer.go))

#### Нужно

- Реализовать интерфейс `http.ResponseWriter` и добавить к своему типу метод `GetResponse() (*http.Response, error)` для
  использования на сервере
- Ожидаемая логика работа примерно аналогична стандартной при работе с HTTP в Go, все требуемые корнеркейсы проверяются
  в тестах.

**Еще раз, важно:** имплементации из пакета `net/http` конечно приватные, но даже если у вас как-то получится, ими все
еще
нельзя пользоваться.

#### Полезное

1) [http.ResponseWriter](https://pkg.go.dev/net/http#ResponseWriter)

### 4. HTTP сервер ([server/server.go](server/server.go))

#### Нужно

- Реализовать интерфейс `HTTPServer` с методом `ListenAndServe(string, http.Handler) error` и методом `Close() error`
- Использовать TCP listener для принятия соединений
- Использовать написанные ранее функции из пакета `convert/` для парсинга/записи запросов и ответов
- Использовать `myResponseWriter` для получения ответа из `http.Handler`

**Еще раз, важно:** в последний раз, нельзя пользоваться `http.ListenAndServe`, `http.Server` и т.д.

#### Полезное

1) Пакет [net](https://pkg.go.dev/net#pkg-overview) с основными сетевыми примитивами
2) Для вдохновения [http.Server](https://pkg.go.dev/net/http#hdr-Servers)

### 5. HTTP Handler ([handler.go](handler.go))

#### Нужно

- Реализовать свой хэндлер подходящй как `http.HandlerFunc`
- По логике работы хэндлера:
    - Принимаем только запросы с методами GET и POST, остальные отбрасываем с соответствующим кодом ответа
    - В случае если не передан заголовок Authorization (не важно с каким содержимым), отбрасываем с соответствующим
      кодом ответа
    - Сама функция должна принимать `name` и возвращать `Hello, <name>!`
    - Если запрос GET - параметры принмаем в query, возвращаем как `text/plain`
    - Если запрос POST - параметры принимаем в теле запроса в формате JSON (ключ `name`), возвращаем тоже в JSON (ключ
      `greeting`)
    - Если запрос выполнен успешно - пишем дополнительный заголовок `X-Custom-Result: success`

### 6. Вопросы по заданию

После выполнения надо ответить на вопросы в [questions.md](questions.md)

#### Полезное

1) [http.HandlerFunc](https://pkg.go.dev/net/http#HandleFunc)
   и [http.HandleFunc](https://pkg.go.dev/net/http#HandleFunc)
2) [json.Marshal](https://pkg.go.dev/encoding/json#Marshal)
   и [json.Unmarshal](https://pkg.go.dev/encoding/json#Unmarshal)

## Тестирование и запуск

Для всех файлов, в которых вам нужно реализовать логику, есть файлы тестов называнные `<filename>_test.go`, вот
структура задания:

```
├── README.md                    Описание задания
│
├── convert                      Пакет для задачи 1
│   ├── http.go                  Ваша логика (де)сериализации
│   └── http_test.go             Тесты для задачи 1
│   
├── client                       Пакет для задачи 2
│   ├── client.go                Ваша логика отправки HTTP запросов
│   ├── client_test.go           Тесты для задачи 2
│   └── contract.go              Контракт который нужно имплементировать
│   
├── server                       Пакет для задач 3 и 4
│   ├── response_writer.go       Задача 3, ваша логика для ResponseWriter
│   ├── response_writer_test.go  Тесты для задачи 3
│   │
│   ├── contract.go              Контракт который нужно имплементировать
│   ├── server.go                Задача 4, ваша логика сервера
│   └── server_test.go           Тесты для задачи 4
│
├── handler.go                   Задача 5, ваша логика handler'а
├── handler_test.go              Тесты для задачи 5
│
├── main.go                      Пример работы связки наших имплементаций
├── main_test.go                 Тесты на логику работы всех компонентов вместе
└── questions.md                 Задача 6, вопросы по заданию
```

### Запуск тестов

1. Все тесты

```bash
go test -v ./...
```

2. Конкретный пакет

```bash
go test -v ./client
```

### Ручной пример работы вашего клиента и сервера

Сервер запустится на порту 8080 (или из переменной окружения PORT), клиент отправит тестовый запрос, и мы напечатаем что
получили в response.

```bash
go run main.go
```

